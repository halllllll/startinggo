## 構造体とインターフェース
* <code>struct</code>と<code>interface</code>について
### ポインタ
#### ポインタの定義のとこで気になったやつ
* Goにおけるポインタは<code>*int</code>みたいな表記で表す。つまりよくある感じのやつ
* Goでは<code>*[4]float64</code>みたいな感じで、「要素数4でfloat型配列のポインタ型」という感じ
    * ただしスライスとかマップとかチャネルはそもそも参照型なのでポインタ型で表してもとくに意味はない（書くことはできる）
* GOでは定義のみを行ったポインタは<code>nil</code>になる
* ポインタのポインタもできるけどGoでつかうことはまずない
* というかそもそもCと比べてポインタをつかうシチュエーションが限られている
#### アドレス演算子とデリファレンスのとこで気になったやつ

* アドレス演算子<code>&</code> まあこれもよくあるふつうのアドレス演算子と同じ
* 任意の型からそのポインタ型を生成できる
    ```
	var i int
	ptr := &i
	fmt.Printf("%T\n", ptr)	//intのポインタ型
	ptrptr := &ptr
	fmt.Printf("%T\n", ptrptr) //intのポインタのポインタ型
    ```
* ポインタ型の変数から値を参照したり（デリファレンス）操作したりする。このへんもよくあるふつうの仕様と同じ
    ```
	i = 5
	fmt.Println(*ptr) //ポインタ型変数ptrの参照先
	*ptr *= 2         //そのまんま直接操作もできる
	fmt.Println(i)
    ```
* 関数にアドレスを渡すやつ。これもよくあるry
    ```
    ii := 1
    pp := &ii
    some(pp)
    fmt.Println(ii, *pp)

    // intのポインタ型を受け取って直接操作する
    func some(i *int) {
        *i *= 999
    }
    >>> 999 999
    ```
* Goでは配列が値型ゆえポインタ型で操作すればもとの配列もいじれる
    ```
    arry := [3]int{1, 2, 3}
    ary_bai(&arry)
    fmt.Println(arry)
    ary_bai(&arry)
    fmt.Println(arry)
    ary_bai(&arry)
    fmt.Println(arry)

    // [3]intの配列のポインタ型を受け取って操作する
    func ary_bai(ap *[3]int) {
        for i := 0; i < 3; i++ {
            // 演算子によっては計算順序の違いからエラーをくらうことになる（* がポインタ演算子か乗算かの区別がつかない）ので()でくくってデリファレンスであることを明示する
            (*ap)[i] *= (*ap)[i]
            //ただしGoでは自動的に配列の要素の参照であると判断してくれるらしいのでこれでもいい
            ap[i] *= ap[i]
        }
    }
    >>> [1 4 9]
    >>> [1 16 81]
    >>> [1 256 6561]
    ```
    コード内にも書いたように、Goでは<code>(*p)[i]</code>のような書き方をしなくても<code>p[i]</code>だけでいい
    * lenやcapやスライス式でも同じく
    * rangeも同じく
    ```
	strings := [3]string{"smoke", "weed", "everyday"}
	stp := &strings
	fmt.Println((*stp)[0], stp[0], strings[0])
    //ほんとは二番目のやつはイレギュラーだがGoではコンパイラが自動的にデリファレンスからの配列の要素の参照だと判断してくれる
	for i, v := range stp {
		fmt.Println(i, v)
	}
    ```
* <code>fmt.Printf()</code>で書式指定子<code>%p</code>を使えば実際のアドレス値がわかる。べつにわかんなくて困るシチュそんなでくわさない

#### 文字列とポインタのとこで気になったやつ
* Goではstringがイミュータブルなので、string型の要素であるbyte型をポインタでいじろうとするとエラーを起こす
    * stringを参照渡しするようなシチュは基本的に存在しない
### 構造体
* Goにはクラスとか無いよ
* フィールド変数は指定しなくてもいけるよ
    * メリットは不明、せいぜい構造体の中に構造体がある場合に内側の構造体にフィールド変数名を割り当てなくてもアクセスできる、ってくらい？
        * でもたくさん構造帯を作るときにいちいち考えなくてもいいのは楽か。
    * 異なる構造体で共通の要素を別の構造体として規定して使いまわせる、というメリットがあるらしい 
    * なんにせよなんか積極的に省略していこうという気概が教科書から感じられる
* そもそも代入も参照もできない無名フィールドも作れるよ（メリットは無い）
#### typeのとこで気になったやつ
* <code>type 定義する型 既存の方</code>みたいな感じ
* （型の）エイリアスとか作る。競プロerの<code>#define ll long long</code>みたいな感じ
* 関数もエイリアス作れる
    * 書いたサンプルがなぜか動かずわけわからんくなったので無視
* まとめて定義できる。
    ```
    //typeでまとめてエイリアスを定義
    type (
        i_pair [2]int
        rgba   [3]float64
        i_chan chan int
        s_chan chan string
    )

    func main() {
        pair := i_pair{-1, 3}
        col := rgba{0.334, 0.233, 0.734}
        fmt.Println(pair, col)
    }
    ```
* 同じ型をベースにした異なる型のエイリアスをtypeでを作ってもベースにした型とは互換性があるが別のエイリアスとは互換性がない
    * つまりintからtypeで２つの型T0,T1を作ったとき、T0+10とかはできるがT0-T1とかはできない（型にオペレーターが定義されていない？）
#### 構造体の定義のとこで気になったやつ
* <code>type 構造体名 struct {フィールドの定義}</code>>という感じ。structだけで定義できるようにしたほうがいいんじゃないの？？と思わんでもない（structつかうときどうせかならずtypeが必要になるの邪魔くさい）
####  複合体リテラルのとこで気になったやつ
* 構造体を定義しつつ各フィールドに初期値を与えるリテラル。二種類
* 構造体で定義された順番に指定する
* 明示的にフィールド変数名を指定（指定がなければ初期値になる）
    ```
    type Point struct {
	    x, y, z int
    }
	//複合リテラル 2種類
	pt1 := Point{10, 3, 5}   //定義された順に指定
	pt2 := Point{z: 8, x: 4} //明示的に指定（初期化してないやつは初期値になる）
	fmt.Println(pt1, pt2
    >>> {10 3 5} {4 0 8}
    ```
#### 構造体を含む構造体のとこで気になったやつ
* ふつうに複合リテラルで定義できる
* 構図体の中の構造体のフィールドにアクセスするときは<code>変数名.内側の構造体名.内側の構造体のフィールド名</code>みたいな感じ
    ```
    type Friends struct {
        Name   string
        Appear Appear //Goではよくあるので気にすんな
    }

    type Appear struct {
        Serif string
        Ep    int
    }

    sarval := Friends{
        Name: "サーバル",
        Appear: Appear{
            Serif: "食べないよ!!",
            Ep:    1, //カンマ必須
        }, //カンマ必須
    }
    fmt.Println(sarval)
    //内側の構造体にアクセス
    fmt.Println(sarval.Appear.Serif)
    ```
    また、フィールド変数名を指定しない場合だとこういう感じになる
    ```
    type Friends struct {
        Name   string
        Appear //フィールド変数名を指定しない
    }

    type Appear struct {
        Serif string
        Ep    int
    }

    sarval := Friends{
        Name: "サーバル",
        Appear: Appear{
            Serif: "食べないよ!!",
            Ep:    1, //カンマ必須
        }, //カンマ必須
    }
    fmt.Println(sarval)
    //内側の構造体にアクセス
    //Appearのフィールド変数が無いのでsarval.Appear.Serifでなくてもアクセスできる
    fmt.Println(sarval.Serif)
    ```
* > ポインタ型の修飾子やパッケージのプリフィックス部分は無視され、純粋な型名の部分が暗黙的なフィールド名として利用されます。

    ということだがうまい例とか覚えてないと大失敗するとかそのへんの想像力が働かない

#### 無名構造体のとこで気になったやつ
* typeなくして<code>struct {フィールド定義}</code>としても使えるが使いみちがほぼ無い
* typeをstructと一緒につかう利用がここにある。すなわち無名構造体もできるっちゃできるから、である。structで定義した構造体にエイリアスをつけているだけ
* よいこのみんなはちゃんとtypeつけて名前をもたせようね

#### 構造体とポインタのとこで気になったやつ
* 構造体は値型なのでポインタつかえば参照渡しになってオブジェクト指向敵な使い方ができるね（早口
* 構造体から<code>&</code>演算子を使ってポインタを生成するよりも、最初から<code>*</code>でポインタを直接生成するほうが見通しが付きやすい
    ```
    //構造体を作ってそのポインタを生成
    p := Point{X: 3, Y: 4, Z: 5}
    pptr = &p   //めんどくさい
    //最初からポインタを直接生成
    p := *Point{X: 3, Y: 4, Z; 5}
    ```
#### newのとこで気になったやつ
* ポインタを生成するしくみとして*演算子をつかう手があるが、Goでは他言語でなじみぶかい<code>new</code>も使える
    ```
    p:=new(Point)
    ```
* ポインタを作るのと動作上の違いはほとんど無いのでどっちでもok
#### メソッドのとこで気になったやつ
* <b>OOPのメソッドとは意味が違う</b>らしい
* 結局似たようにつかうので認識上は同じと思っていい？
### まとめ
* 関数で配列のポインタ型を扱う場合は<code>(*ptr)[i]</code>というふうに括弧でくくっちまうのはCとかいう野蛮な言語を操る連中で、Goではそのまま書いても配列の要素の参照に展開してくれる
* newあるんですね