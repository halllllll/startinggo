## 参照型とは
* よくある参照型の認識で構わない？
* goではスライス、マップ、チャネルのデータ構造が標準で相当する
### make関数
* スライス、マップ、チャネルはいずれも<code>make</code>関数によって作成される。
### スライス
* いちばん使うデータ構造。可変長配列のための型みたいなもん
* <code>s:=make([]int, 10)</code>という感じ。要素数10のint型のスライス
* 容量を指定する場合は
    ```
    s:=make([]int, 5, 10)
    ```
    という形。 これで要素数5, 容量10のスライスが定義される（後述）
* また、配列ライクに定義することも可能。この場合は要素数=容量となる
    ```
    s:=[]int{1, 2, 3, 4, 5}
    ```
* 見た目はあまり配列と変わらん。配列数が表示されるかどうか
    * <code>reflect.TypeOf</code>や<code>fmt.Prinltf("%#v", slice)</code>で型を表示
* 代入も参照も配列と同じ文法で実現できる
    * スライスの要素数を超過した要素へのアクセスはパニックを起こす
    * <code>panic: runtime error: index out of range</code>
* <code>len</code>で要素数を得られる
* <code>cap</code>で容量capacityを得られる
* 容量はスライスが将来使うかもしれない領域を予め確保しておいたもの
    * 可変長配列とはいえGo的には新たにメモリ領域を確保し直すのは負荷が高い処理らしい
    * したがって予めどの程度の容量が必要になるかの見積もりもパフォーマンスのためには必要
* 配列やスライスをもとにして新たなスライスを作ることができる。<b>簡易スライス式</b>とかいうらしい
    ```
    array:=[5]int{10, 4, 2, -5, 3}
    slice:=array[2:]
    ```  

* 簡易スライス式は文字列にも使えるが、配列のとこでやったように<b>文字列をバイト列としてみなしたうえでのインデックスを指定する必要がある</b>。utf8だと日本語は１文字につき3byte必要なので3区切りのインデックスを指定してやらねばならない
* <code>append</code>でスライスを拡張する
    * <code>newslice := append(slice, sliceの要素型の要素1, 要素2, ....)</code>
    * また、スライス同士の結合も可能。その場合は第二引数の末尾に...をつける
    ```
    slicea := make([]int, 4)
	sliceb := []int{3, 3, 0}
	slicec := append(slicea, sliceb...)
	fmt.Println(slicec, cap(slicec))
    >> [0 0 0 0 3 3 0] 8
    ```
    ちなみに3つ以上のスライスの結合はどうやるのかわからんしできるとも限らない

#### copyのとこで気になったやつ
* スライスにスライスの値をコピーするときの組み込み関数
    ```
    slicea := make([]int, 4)
    sliceb := []int{3, 3, 0}
    n := copy(slicea, sliceb)
    fmt.Println(n, slicea)
    >> 3 [3 3 0 0]
    ```
    戻り値はなぜか<b>「コピーされた要素数」</b>であることに注意。実際には第一引数のスライスに第二引数のスライスを上書きコピーする。
* コピー先の要素数のほうが大きい場合はそのまま先頭から順にコピーされるだけだが、逆にコピー元のほうが大きい場合はコピー先の容量を越えて増えることはない。上のコードでsilceaとslicebを逆にしてcopyすると
    ```
    >>> 3 [0 0 0]
    ```
    になる
##### 完全スライス式のとこで気になったやつ
* 配列やスライスからスライスを作るときにその容量をコントロールする
* 通常、要素10容量10の配列またはスライスから簡易スライス式を使って部分スライス[2:4]を抽出すると要素数2, 容量8のスライスになる
    ```
    関係: 0<=low<=high<=max<=cap(もとの配列またはスライス)
    完全スライス式: a[low:high:max]（aは配列またはスライス）
    簡易スライス式: a[low:high]

    ①簡易スライス式で新たに作られたスライスの容量=len(a)-low
    ②完全スライス式で新たに作られたスライスの容量=max-low
    ```
    すなわち、①より、要素10容量10から[2:4]として抽出たスライスの容量は10-2=8となる。
    完全スライス式で作るときはこの8を越えない範囲で容量の最大値を指定できるというわけ
* 教科書の図を見たほうが速い

##### スライスとforのとこで気になったやつ
* rangeを使った範囲節for。配列とおなじ
    * スライスの各要素に対して操作を行うようなループだと、たとえばループの条件節に要素数をiが越えないみたいな感じにしたうえでループ内でappendしたりすると無限ループになる（わかりにくい
    * rangeを使ったループだとそういうことにはならない。rangeの場合はループ開始時点での要素数を対象とするのでスライスをループ内で変更しても影響はない（わかりにくい
* 要は、<b>スライスをループしたいときはrangeを用いた範囲節forでやれ</b>ということ

##### スライスと可変長引数のとこで気になったやつ
* <code>fmt.Printf()</code>とかは可変長引数、それにスライスが使われている
* 可変長引数をとる関数
    ```
    func sum(slices ...int)int{
        // ぜんぶ足すだけ
        ans:=0
        for _,v := range slices{
            ans+=v
        }
        return ans
    }
    ```
    <code>slices ...int</code>のように型名の前に<code>...</code>をつけているところがポイント。
* 可変長引数は引数の最後にひとつだけ指定できる。pythonと似たようなもん
* スライスを可変長引数に渡す場合は変数名の前に<code>...</code>をつける
    ```
    //スライスを可変長引数として使う
    integers:=[]int{4, 2, 3, 6, 0, 10, -20}
    fmt.Println(sum(integers...))
    ```
### まとめ
* スライスは可変長配列
* スライスは要素数と容量という概念を持つ
* 容量を越えた範囲でスライスを拡張しようとすると、自動的に容量を増やして確保してコピーする
    * これはなかなかコストが高い処理
* スライスをループするときはrange使え