## 構造体とインターフェース
* <code>struct</code>と<code>interface</code>について
### ポインタ
#### ポインタの定義のとこで気になったやつ
* Goにおけるポインタは<code>*int</code>みたいな表記で表す。つまりよくある感じのやつ
* Goでは<code>*[4]float64</code>みたいな感じで、「要素数4でfloat型配列のポインタ型」という感じ
    * ただしスライスとかマップとかチャネルはそもそも参照型なのでポインタ型で表してもとくに意味はない（書くことはできる）
* GOでは定義のみを行ったポインタは<code>nil</code>になる
* ポインタのポインタもできるけどGoでつかうことはまずない
* というかそもそもCと比べてポインタをつかうシチュエーションが限られている
#### アドレス演算子とデリファレンスのとこで気になったやつ

* アドレス演算子<code>&</code> まあこれもよくあるふつうのアドレス演算子と同じ
* 任意の型からそのポインタ型を生成できる
    ```
	var i int
	ptr := &i
	fmt.Printf("%T\n", ptr)	//intのポインタ型
	ptrptr := &ptr
	fmt.Printf("%T\n", ptrptr) //intのポインタのポインタ型
    ```
* ポインタ型の変数から値を参照したり（デリファレンス）操作したりする。このへんもよくあるふつうの仕様と同じ
    ```
	i = 5
	fmt.Println(*ptr) //ポインタ型変数ptrの参照先
	*ptr *= 2         //そのまんま直接操作もできる
	fmt.Println(i)
    ```
* 関数にアドレスを渡すやつ。これもよくあるry
    ```
    ii := 1
    pp := &ii
    some(pp)
    fmt.Println(ii, *pp)

    // intのポインタ型を受け取って直接操作する
    func some(i *int) {
        *i *= 999
    }
    >>> 999 999
    ```
* Goでは配列が値型ゆえポインタ型で操作すればもとの配列もいじれる
    ```
    arry := [3]int{1, 2, 3}
    ary_bai(&arry)
    fmt.Println(arry)
    ary_bai(&arry)
    fmt.Println(arry)
    ary_bai(&arry)
    fmt.Println(arry)

    // [3]intの配列のポインタ型を受け取って操作する
    func ary_bai(ap *[3]int) {
        for i := 0; i < 3; i++ {
            // 演算子によっては計算順序の違いからエラーをくらうことになる（* がポインタ演算子か乗算かの区別がつかない）ので()でくくってデリファレンスであることを明示する
            (*ap)[i] *= (*ap)[i]
            //ただしGoでは自動的に配列の要素の参照であると判断してくれるらしいのでこれでもいい
            ap[i] *= ap[i]
        }
    }
    >>> [1 4 9]
    >>> [1 16 81]
    >>> [1 256 6561]
    ```
    コード内にも書いたように、Goでは<code>(*p)[i]</code>のような書き方をしなくても<code>p[i]</code>だけでいい
    * lenやcapやスライス式でも同じく
    * rangeも同じく
    ```
	strings := [3]string{"smoke", "weed", "everyday"}
	stp := &strings
	fmt.Println((*stp)[0], stp[0], strings[0])
    //ほんとは二番目のやつはイレギュラーだがGoではコンパイラが自動的にデリファレンスからの配列の要素の参照だと判断してくれる
	for i, v := range stp {
		fmt.Println(i, v)
	}
    ```
* <code>fmt.Printf()</code>で書式指定子<code>%p</code>を使えば実際のアドレス値がわかる。べつにわかんなくて困るシチュそんなでくわさない

#### 文字列とポインタのとこで気になったやつ
* Goではstringがイミュータブルなので、string型の要素であるbyte型をポインタでいじろうとするとエラーを起こす
    * stringを参照渡しするようなシチュは基本的に存在しない
### 構造体
* Goにはクラスとか無いよ
* フィールド変数は指定しなくてもいけるよ
    * メリットは不明、せいぜい構造体の中に構造体がある場合に内側の構造体にフィールド変数名を割り当てなくてもアクセスできる、ってくらい？
        * でもたくさん構造帯を作るときにいちいち考えなくてもいいのは楽か。
    * 異なる構造体で共通の要素を別の構造体として規定して使いまわせる、というメリットがあるらしい 
    * なんにせよなんか積極的に省略していこうという気概が教科書から感じられる
* そもそも代入も参照もできない無名フィールドも作れるよ（メリットは無い）
* フィールドや構造体名も頭文字大文字で公開される
* メソッドも
* フィールドを非公開に、メソッドは公開にすれば隠蔽性が高くてメンテナンス的にもgood
#### typeのとこで気になったやつ
* <code>type 定義する型 既存の方</code>みたいな感じ
* （型の）エイリアスとか作る。競プロerの<code>#define ll long long</code>みたいな感じ
* 関数もエイリアス作れる
    * 書いたサンプルがなぜか動かずわけわからんくなったので無視
* まとめて定義できる。
    ```
    //typeでまとめてエイリアスを定義
    type (
        i_pair [2]int
        rgba   [3]float64
        i_chan chan int
        s_chan chan string
    )

    func main() {
        pair := i_pair{-1, 3}
        col := rgba{0.334, 0.233, 0.734}
        fmt.Println(pair, col)
    }
    ```
* 同じ型をベースにした異なる型のエイリアスをtypeでを作ってもベースにした型とは互換性があるが別のエイリアスとは互換性がない
    * つまりintからtypeで２つの型T0,T1を作ったとき、T0+10とかはできるがT0-T1とかはできない（型にオペレーターが定義されていない？）
#### 構造体の定義のとこで気になったやつ
* <code>type 構造体名 struct {フィールドの定義}</code>>という感じ。structだけで定義できるようにしたほうがいいんじゃないの？？と思わんでもない（structつかうときどうせかならずtypeが必要になるの邪魔くさい）
####  複合体リテラルのとこで気になったやつ
* 構造体を定義しつつ各フィールドに初期値を与えるリテラル。二種類
* 構造体で定義された順番に指定する
* 明示的にフィールド変数名を指定（指定がなければ初期値になる）
    ```
    type Point struct {
	    x, y, z int
    }
	//複合リテラル 2種類
	pt1 := Point{10, 3, 5}   //定義された順に指定
	pt2 := Point{z: 8, x: 4} //明示的に指定（初期化してないやつは初期値になる）
	fmt.Println(pt1, pt2
    >>> {10 3 5} {4 0 8}
    ```
#### 構造体を含む構造体のとこで気になったやつ
* ふつうに複合リテラルで定義できる
* 構図体の中の構造体のフィールドにアクセスするときは<code>変数名.内側の構造体名.内側の構造体のフィールド名</code>みたいな感じ
    ```
    type Friends struct {
        Name   string
        Appear Appear //Goではよくあるので気にすんな
    }

    type Appear struct {
        Serif string
        Ep    int
    }

    sarval := Friends{
        Name: "サーバル",
        Appear: Appear{
            Serif: "食べないよ!!",
            Ep:    1, //カンマ必須
        }, //カンマ必須
    }
    fmt.Println(sarval)
    //内側の構造体にアクセス
    fmt.Println(sarval.Appear.Serif)
    ```
    また、フィールド変数名を指定しない場合だとこういう感じになる
    ```
    type Friends struct {
        Name   string
        Appear //フィールド変数名を指定しない
    }

    type Appear struct {
        Serif string
        Ep    int
    }

    sarval := Friends{
        Name: "サーバル",
        Appear: Appear{
            Serif: "食べないよ!!",
            Ep:    1, //カンマ必須
        }, //カンマ必須
    }
    fmt.Println(sarval)
    //内側の構造体にアクセス
    //Appearのフィールド変数が無いのでsarval.Appear.Serifでなくてもアクセスできる
    fmt.Println(sarval.Serif)
    ```
* > ポインタ型の修飾子やパッケージのプリフィックス部分は無視され、純粋な型名の部分が暗黙的なフィールド名として利用されます。

    ということだがうまい例とか覚えてないと大失敗するとかそのへんの想像力が働かない

#### 無名構造体のとこで気になったやつ
* typeなくして<code>struct {フィールド定義}</code>としても使えるが使いみちがほぼ無い
* typeをstructと一緒につかう利用がここにある。すなわち無名構造体もできるっちゃできるから、である。structで定義した構造体にエイリアスをつけているだけ
* よいこのみんなはちゃんとtypeつけて名前をもたせようね

#### 構造体とポインタのとこで気になったやつ
* 構造体は値型なのでポインタつかえば参照渡しになってオブジェクト指向敵な使い方ができるね（早口
* 構造体を<code>&</code>つけて関数に渡す（関数では<code>*</code>つきで受取る）よりも、構造体のポインタを直接生成するほうが見通しがつきやすい
    ```
    //構造体を作ってそのポインタを生成
    p := Point{X: 3, Y: 4, Z: 5}
    somefunc(&p)   //めんどくさい（somefuncではp *Point）としてPointのポインタを受取る
    //最初からポインタを直接生成
    p := &Point{X: 3, Y: 4, Z; 5}
    somefunc(p)
    ```
#### newのとこで気になったやつ
* ポインタを生成するしくみとして*演算子をつかう手があるが、Goでは他言語でなじみぶかい<code>new</code>も使える
    ```
    p:=new(Point)
    ```
* ポインタを作るのと動作上の違いはほとんど無いのでどっちでもok
#### メソッドのとこで気になったやつ
* <b>OOPのメソッドとは意味が違う</b>らしい
* 結局似たようにつかうので認識上は同じと思っていい？
* 表記上はめっちゃわかりやすそう。funcとメソッド名の間に<b>レシーバー</b>の型とその名前を()でくくる
    * レシーバーがなんなのかについての説明はなされていない
    * <code>func (レシーバー名 レシーバーの型) 関数名(引数 引数の型) 戻り値 {処理}</code>
    * ふつうに引数と戻り値は省略可能
    ```
    //Point間の距離を求めるよくあるやつ
    func (p *Point) Dist(ap *Point) float64 {
        x, y := p.X-ap.X, p.Y-ap.Y
        return math.Sqrt(float64(x*x + y*y))
    }
	p := &Point{X: 3, Y: 10}
	p2 := &Point{X: 2, Y: 4}
	dist := p.Dist(p2)
	fmt.Println(dist)
    >>> 6.082762530298219
    ```
* レシーバーの型が異なっていれば同名のメソッドを定義可能
* <b>エイリアスを使えば基本型にもメソッドを定義できる</b>。互換性あるからなんかうまい具合に便利メソッド作れそう
    * 配列型のエイリアスを作って先頭/末尾の要素を返すやつとか
    * あと、ほら、lower_bound的なやつとか。。。
        * 作ってみるかと思ってソートを調べたらなんかインターフェースがどうたらとか言われてまだ速いなと思った次第
        * 代わりに累積和メソッドでお茶を濁す
        ```
        // この場合レシーバーに*は不要
        func (is Integars) RuisekiSum() []int {
            //ふつうにlenもrangeも使えるんですね
            res := make([]int, len(is))
            res[0] = is[0]
            sum := res[0]
            for i := 1; i < len(is); i++ {
                sum += is[i]
                res[i] = sum
            }
            return res
        }

        type Integars []int
        lis := Integars{-4, 2, 20, 5, -8, 3, 5, 2, 2, 4}
        fmt.Println(lis.RuisekiSum())

        >>> [-4 -2 18 23 15 18 23 25 27 31]
        ```
#### 型のコンストラクタのとこで気になったやつ
* コンストラクタは無いが型のコンストラクタならある（？
* 慣例的に<code>func New型名(フィールド フィールドの型, ...) 型のポインタ型{初期化処理;return 自分自身}</code>という感じで定義
    * なんかこの自分自身というかthisとかインスタンスとかの概念ないとなんていうのかわからんな
    ```
    //型のコンストラクタで初期化処理してみる
    type Yome struct {
        ID   int
        Name string
        Sex  int
        Tags []string
    }

    func NewYome(id int, name string) *Yome {
        //最初に自分自身のなんつーかインスタンス的なやつを作る
        y := new(Yome)
        y.ID = id
        y.Name = name
        y.Sex = 0
        y.Tags = []string{"ここに素晴らしい属性が入ります"}
        //で最後に返す
        return y
    }
    myyome := *NewYome(0, "谷川柑菜")
    fmt.Println(myyome)
    ```
#### 関数としてのメソッドのとこで気になったやつ
* > メソッドを関数型として参照するときには,「［レシーバーの型］.［メソッド］」のように書くことができます。
* > メソッドはレシーバーを第1引数としてとる単なる関数にすぎません。
* > メソッドを関数型として参照する場合にはもう1つ、「［レシーバー］.［メソッド］」という書き方もあります。
* <strong>わからん</strong>

### まとめ

* 関数で配列のポインタ型を扱う場合は<code>(*ptr)[i]</code>というふうに括弧でくくっちまうのはCとかいう野蛮な言語を操る連中で、Goではそのまま書いても配列の要素の参照に展開してくれる
* newあるんですね
* 構造体はフィールドを非公開に、メソッドは公開にすれば隠蔽性が高くてメンテナンス的にもgood（二回目