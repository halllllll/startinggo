#### カンマのとこで気になったやつ
* Goでは文末？文端？でコンパイラが自動的に<code>;</code>を付けて文の終わりとみなす
* なので、  
<code>
	cities:=[]string{</br>
        "tokyo",</br>
        "paris",</br>  
        "Roma",</br>  
        "Sri Jayawardenepura Kotte" </br>
	}  
</code>は最後の要素に<code>;</code>がつけられてしまい構文エラーとなる

#### fmtパッケージのとこで気になったやつ
* fmt.Printf
    * よく出てきたけど書式指定子を使える。フォーマット文字列。
    * <code>fmt.Printf("I'm %d years old.", 100)</code>みたいな
    * 書式指定子、まったく覚えられんまま十進数とか文字とかだけ知ってりゃどこでも使えるやろとヘラヘラしてたんだけどGoだと<code>%v</code>とか<code>%#v</code>とか特殊なのが出てくるのよ
    * 
        | 書式指定子 | 意味 |
        |:------------:|:------------|
        | %d | 10進数(decimal) |
        | %b | 2進数(binary) |
        | %o | 8進数(octal) |
        | %h | 16進数(hexadecimal) |
        | %f | 浮動小数点数 |
        | %e, %g | 指数とか複素数<br>違いがよくわからん、どちらも両方使える |
        | %s | string |
        | %v | デフォルトフォーマット<br>いろんな型を読み込める |
        | %#v | Goのリテラルで表現 |
        | %T | 型情報 |
    など。他は[golang.jp - fmt パッケージ](http://golang.jp/pkg/fmt)参照

#### print, printlnのとこで気になったやつ
* 標準出力じゃなくて標準エラー出力
* VSC上はどちらも出力コンソールに表示されるしどういうことかはよくわからんが
* 型が「変数型」「値型」「ポインタ型」の3つに分類されるのってけっこう特殊な気がするんだけどCとかってそうなのかな

#### 変数定義の詳細のとこで気になったやつ
* Goの変数は関数内で定義されるローカル変数とパッケージに依存するパッケージ変数の二種類
    * パッケージ変数はプログラムのどこからでも参照可能なので実質グローバル変数なのではないか
    * （言語仕様上はグローバル変数は定義されていないらしい？）
    * つまり、所属するパッケージ内で定義された（ローカル変数でない、関数スコープの外で定義された）変数はそのパッケージに依存するどのプログラムからも参照可能ってことか
    * やってみた（さっそくビルドの仕方を忘れていた。。<code>go run 同じパッケージを定義しているすべてのgoファイルを列挙</code>で通る）[これ](https://github.com/halllllll/startinggo/tree/master/chap3/variabledifinite_sample)

#### 数値型のとこで気になったやつ
* byte型==int8型。どちらでもいいんかい（そりゃそうだが。。。）
* 実装依存の整数型
    * 32bitなGoか(<code>int</code>)64bitなGoか(<code>uint</code>)、あとOSによってはポインタを整数にするときにどのくらいの大きさになるかわからんので<code>uintptr</code>型なんてのもあるらしい
    * 書いたけどぜんぜんわかってない
* 8進数のリテラルが単に0をつけただけの<code>0393</code>みたいな感じで表される
    * どっかでハマりそう
* 符号なし整数値にするには明示的なキャストが必要
    * ふつうに整数リテラルで定義したんじゃintかuintかわからんもんね（仕様上intに収まるらしい

#### 浮動小数点型のとこで気になったやつ
* 明示的に宣言しない限りfloat64型になる

#### 複素数型のとこで気になったやつ
* <code>complex64</code>型と<code>complex128</code>型で、前者が実部・虚部に32bitずつ、後者は64bitずつ
* リテラルに則って定義するか、complex関数が組込みで存在する。戻り値はcomplex128

#### rune型のとこで気になったやつ
* 厨二
* int32型と同じ
* シングルクォートで囲まれたUnicode文字
    * すべてのUnicode文字を単一の型で表そうとしている？32bitありゃたぶん間に合うだろって感じ

#### RAW文字リテラルのとこで気になったやつ
* バッククォート``で囲むとRAW文字になる

#### 配列型のとこで気になったやつ
* 要素数の省略。<code>arr:=[...]int {1, 2, 4, 8}</code>
* 要素数が異なれば別の型になる<br>
<code>
	ar1 := [3]string{"カバさん", "アリクイさん", "あんこう"}<br>
	ar2 := [5]string{"うさぎさん", "カメさん", "レオポンさん", "カモさん", "アヒルさん"}<br>
	ar1type, ar2type := reflect.TypeOf(ar1), reflect.TypeOf(ar2)<br>
	if ar1type != ar2type{<br>
		fmt.Println(ar1type, ar2type)<br>
	}<br>
</code>

* 値型（!!!!!!!!!!!!!）

#### interfaceとNilのとこで気になったやつ
* <code>var x interface{}</code>で定義
* object型みたいなもんらしい
    * なんでも代入できる
* 初期値Nil
* 詳しくはあとでやるっぽい

### 関数
* Goは非オブジェクト指向
* OOPでいうところのメソッドはGoで使われるメソッドと意味が異なるらしい　よくわからんが
#### 関数型のとこで気になったやつ
* 
#### エラー処理のとこで気になったやつ
* <b>Goには例外機構がない</b>。関数が複数の戻り値を返すことができるのでそれを利用する
* 戻り値で<code>err</code>とするのはGoのイディオム
    * たとえば<code>if(err!=Nil)</code>などとしてエラーが発生したかどうかを判断する
#### 無名関数のとこで気になったやつ
* lambda式的な、あるいはジェネレータ的な
* 実際はクロージャらしい
* 関数を値のように扱うことで、引数に関数をとる関数や関数を返す関数とか作れる
* 関数を返す関数<br>
<code>
//string型の引数を受け取って戻り値のない関数を返す関数<br>
func retfunc(a string) func(){<br>
    return func(){<br>
       fmt.Println(a)<br>
    }<br>
}<br>
//string型の引数を受け取って「string型を返す関数」を返す関数<br>
func retfunc2(a string) func()string{<br>
	return func()string{<br>
		return a+"!!!!!!!!!!!"<br>
	}<br>
}
</code>
* 関数を引数にとる関数<br>
<code>//戻り値のない関数を引数にとる戻り値のない関数<br>
func callfunc(f func()){<br>
	f()<br>
}<br>
func main(){<br>
	callfunc(func(){fmt.Println("わかりづらい")})<br>
}</code>

* クロージャとして使える。内部関数（Goではそのような言い方をされるのかは知らんが）から外部関数のローカル変数を参照することで、本来実行語に消去されるローカル変数を保ちつづける

### 定数
* <code>const</code>キーワードで定数を定義できる
* まとめて定義するときは最初に定義したものが自動的にあとから宣言した変数に代入される
* 式も書ける。ほかで定義されている定数も含めることができる
* <b>基本型の整数型と定数の整数値は本質的に異なる</b>。型あり定数は明示的に<code>const I int64=100</code>などと定義される。
    * あるいは<code>const I = (int64)100</code>のほうがわかりやすい
* 定数同士の演算はコンパイル時に処理される

#### iotaのとこで気になったやつ
* 列挙子など存在しないが、こいつを使えば実現できる
* >iotaは参照の有無によらずconstブロックの中で定数が定義されるたび に1ずつ増分します。カウンターのようなイメージではなく、定数群に付与されたインデックスとしてイメージするほうがより適切かもしれません。

#### 識別子のとこで気になったやつ
* 変数名、関数名、定数名はGoにおいては<b>識別子</b>とされる。
* （つまりどういうことだってばYOO）

### スコープ
* Goにおけるスコープ、大きい単位から順に、<b>パッケージ</b>, <b>ファイル</b>, <b>関数</b>, <b>ブロック</b>, <b>制御構文</b>
* 変数、関数、定数、型はすべてパッケージに属する
#### パッケージのスコープのとこで気になったやつ
* パッケージに定義された識別子がほかのパッケージから参照できるかどうかは<b>識別子の1文字目が大文字であるかどうか</b>で決定される
    * Chap2でハマったところ回収
* 参照先の（ほかのパッケージの）関数が同じパッケージのほかの識別子を参照している場合はもうそこで既に関数にアクセスできているので大文字とか関係なくふつうにそのまま参照できる
#### importの詳細のとこで気になったやつ
* パッケージ名を上書きして任意の名前で呼べる。
    * <code>import f "fmt"</code>みたいな感じ
* パッケージ名を省略できる
    * <code>import . "math"</code>みたいな感じ
    * ただし識別子の衝突に注意。重複した名前を定義するとコンパイルエラーとなる
#### ファイルのスコープのとこで気になったやつ
* 同一パッケージに複数ファイルが含まれる（==複数ファイルでひとつのパッケージを定義している）場合、importはそれぞれのファイル内でのみ有効となり独立する
#### 関数のスコープのとこで気になったやつ
* これはよくあるプログラミング言語の仕様どおりでふつうの関数内スコープ
* 引数や戻り値も識別子のうちなので重複して定義はできない
    * <code>{}</code>がスコープの区切りなので別のスコープの内部だったら大丈夫。つまり関数より深いブロックだったらおｋ
    * まあ重複なんてややこしいからやるなってこった

### 制御構文
* いろんな書き方がある
#### ifのとこで気になったやつ
* <code>{}</code>は省略不可能で、かならずブロックを明示的に書く
* 条件式は<b>かならず論理値で評価する。</b>1がtrueになったり空配列がfalseになったりはしない
* 簡易文を使って条件式に使う変数を定義したりできる<br>
    <code>if x,y:=1,2; x<y{}</code>的な感じ
#### forのとこで気になったやつ
* whileはないけど条件付きforで同じことをできる
* よくあるforの初期化文、条件文、後処理文はいずれも省略可能だし全部なくてもいい（無限ループになる）
* <code>range</code>と一緒に使うのがわりと有用そうだし頻度高そう
    * 順番はpythonのenumerateと同じでインデックス、要素みたいな感じ
* 配列とスライスとマップとかのコレクションだけでなく文字列やチャネルにも使える
    * マップもpythonと同じでkey, valueみたいな感じ
    * 文字列はインデックスと<code>rune</code>型になる
    * Unicodeのコードポイントごとにインデックスが振られるので注意（よくわからん）
#### switchのとこで気になったやつ

    

### まとめ
* ここでやっと書籍内の書式について出て来るの新しい。こっからが本番だという気持ち
* <code>Println</code>のほかにデバッグ用に<code>println</code>があるだなんて
* python的に右辺の配列を左辺の複数の変数に暗黙的にアンジップして代入できないかとかやったけどダメみたいですね( startinggo/chap3/variable_sample1.go )
* パッケージ変数とかいう新概念（ただの名前空間）
* rune型はUnicodeを単一の型でがんばって表そうとしている（?
* 要素数ゼロの配列とか作れる
* 相変わらずクロージャとかよくわからん
* iota、定数との絡みでしか言及されず、ろくな説明もなかったのだが読み方すらわからんのだが一体なんなの
* スコープ、識別子の名前の1文字目で判断できるのヤバイ