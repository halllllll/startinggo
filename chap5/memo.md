## 構造体とインターフェース
* <code>struct</code>と<code>interface</code>について
### ポインタ
#### ポインタの定義のとこで気になったやつ
* Goにおけるポインタは<code>*int</code>みたいな表記で表す。つまりよくある感じのやつ
* Goでは<code>*[4]float64</code>みたいな感じで、「要素数4でfloat型配列のポインタ型」という感じ
    * ただしスライスとかマップとかチャネルはそもそも参照型なのでポインタ型で表してもとくに意味はない（書くことはできる）
* GOでは定義のみを行ったポインタは<code>nil</code>になる
* ポインタのポインタもできるけどGoでつかうことはまずない
* というかそもそもCと比べてポインタをつかうシチュエーションが限られている
#### アドレス演算子とデリファレンスのとこで気になったやつ

* アドレス演算子<code>&</code> まあこれもよくあるふつうのアドレス演算子と同じ
* 任意の型からそのポインタ型を生成できる
    ```
	var i int
	ptr := &i
	fmt.Printf("%T\n", ptr)	//intのポインタ型
	ptrptr := &ptr
	fmt.Printf("%T\n", ptrptr) //intのポインタのポインタ型
    ```
* ポインタ型の変数から値を参照したり（デリファレンス）操作したりする。このへんもよくあるふつうの仕様と同じ
    ```
	i = 5
	fmt.Println(*ptr) //ポインタ型変数ptrの参照先
	*ptr *= 2         //そのまんま直接操作もできる
	fmt.Println(i)
    ```
* 関数にアドレスを渡すやつ。これもよくあるry
    ```
    ii := 1
    pp := &ii
    some(pp)
    fmt.Println(ii, *pp)

    // intのポインタ型を受け取って直接操作する
    func some(i *int) {
        *i *= 999
    }
    >>> 999 999
    ```
* Goでは配列が値型ゆえポインタ型で操作すればもとの配列もいじれる
    ```
    arry := [3]int{1, 2, 3}
    ary_bai(&arry)
    fmt.Println(arry)
    ary_bai(&arry)
    fmt.Println(arry)
    ary_bai(&arry)
    fmt.Println(arry)

    // [3]intの配列のポインタ型を受け取って操作する
    func ary_bai(ap *[3]int) {
        for i := 0; i < 3; i++ {
            // 演算子によっては計算順序の違いからエラーをくらうことになる（* がポインタ演算子か乗算かの区別がつかない）ので()でくくってデリファレンスであることを明示する
            (*ap)[i] *= (*ap)[i]
            //ただしGoでは自動的に配列の要素の参照であると判断してくれるらしいのでこれでもいい
            ap[i] *= ap[i]
        }
    }
    >>> [1 4 9]
    >>> [1 16 81]
    >>> [1 256 6561]
    ```
    コード内にも書いたように、Goでは<code>(*p)[i]</code>のような書き方をしなくても<code>p[i]</code>だけでいい
    * lenやcapやスライス式でも同じく
    * rangeも同じく
    ```
	strings := [3]string{"smoke", "weed", "everyday"}
	stp := &strings
	fmt.Println((*stp)[0], stp[0], strings[0])
    //ほんとは二番目のやつはイレギュラーだがGoではコンパイラが自動的にデリファレンスからの配列の要素の参照だと判断してくれる
	for i, v := range stp {
		fmt.Println(i, v)
	}
    ```
* <code>fmt.Printf()</code>で書式指定子<code>%p</code>を使えば実際のアドレス値がわかる。べつにわかんなくて困るシチュそんなでくわさない

#### 文字列とポインタのとこで気になったやつ
* Goではstringがイミュータブルなので、string型の要素であるbyte型をポインタでいじろうとするとエラーを起こす
    * stringを参照渡しするようなシチュは基本的に存在しない
### 構造体
* Goにはクラスとか無いよ
* フィールド変数は指定しなくてもいけるよ
    * メリットは不明、せいぜい構造体の中に構造体がある場合に内側の構造体にフィールド変数名を割り当てなくてもアクセスできる、ってくらい？
        * でもたくさん構造帯を作るときにいちいち考えなくてもいいのは楽か。
    * 異なる構造体で共通の要素を別の構造体として規定して使いまわせる、というメリットがあるらしい 
    * なんにせよなんか積極的に省略していこうという気概が教科書から感じられる
* そもそも代入も参照もできない無名フィールドも作れるよ（メリットは無い）
* フィールドや構造体名も頭文字大文字で公開される
* メソッドも
* フィールドを非公開に、メソッドは公開にすれば隠蔽性が高くてメンテナンス的にもgood
#### typeのとこで気になったやつ
* <code>type 定義する型 既存の方</code>みたいな感じ
* （型の）エイリアスとか作る。競プロerの<code>#define ll long long</code>みたいな感じ
* 関数もエイリアス作れる
    * 書いたサンプルがなぜか動かずわけわからんくなったので無視
* まとめて定義できる。
    ```
    //typeでまとめてエイリアスを定義
    type (
        i_pair [2]int
        rgba   [3]float64
        i_chan chan int
        s_chan chan string
    )

    func main() {
        pair := i_pair{-1, 3}
        col := rgba{0.334, 0.233, 0.734}
        fmt.Println(pair, col)
    }
    ```
* 同じ型をベースにした異なる型のエイリアスをtypeでを作ってもベースにした型とは互換性があるが別のエイリアスとは互換性がない
    * つまりintからtypeで２つの型T0,T1を作ったとき、T0+10とかはできるがT0-T1とかはできない（型にオペレーターが定義されていない？）
#### 構造体の定義のとこで気になったやつ
* <code>type 構造体名 struct {フィールドの定義}</code>>という感じ。structだけで定義できるようにしたほうがいいんじゃないの？？と思わんでもない（structつかうときどうせかならずtypeが必要になるの邪魔くさい）
####  複合体リテラルのとこで気になったやつ
* 構造体を定義しつつ各フィールドに初期値を与えるリテラル。二種類
* 構造体で定義された順番に指定する
* 明示的にフィールド変数名を指定（指定がなければ初期値になる）
    ```
    type Point struct {
	    x, y, z int
    }
	//複合リテラル 2種類
	pt1 := Point{10, 3, 5}   //定義された順に指定
	pt2 := Point{z: 8, x: 4} //明示的に指定（初期化してないやつは初期値になる）
	fmt.Println(pt1, pt2
    >>> {10 3 5} {4 0 8}
    ```
#### 構造体を含む構造体のとこで気になったやつ
* ふつうに複合リテラルで定義できる
* 構図体の中の構造体のフィールドにアクセスするときは<code>変数名.内側の構造体名.内側の構造体のフィールド名</code>みたいな感じ
    ```
    type Friends struct {
        Name   string
        Appear Appear //Goではよくあるので気にすんな
    }

    type Appear struct {
        Serif string
        Ep    int
    }

    sarval := Friends{
        Name: "サーバル",
        Appear: Appear{
            Serif: "食べないよ!!",
            Ep:    1, //カンマ必須
        }, //カンマ必須
    }
    fmt.Println(sarval)
    //内側の構造体にアクセス
    fmt.Println(sarval.Appear.Serif)
    ```
    また、フィールド変数名を指定しない場合だとこういう感じになる
    ```
    type Friends struct {
        Name   string
        Appear //フィールド変数名を指定しない
    }

    type Appear struct {
        Serif string
        Ep    int
    }

    sarval := Friends{
        Name: "サーバル",
        Appear: Appear{
            Serif: "食べないよ!!",
            Ep:    1, //カンマ必須
        }, //カンマ必須
    }
    fmt.Println(sarval)
    //内側の構造体にアクセス
    //Appearのフィールド変数が無いのでsarval.Appear.Serifでなくてもアクセスできる
    fmt.Println(sarval.Serif)
    ```
* > ポインタ型の修飾子やパッケージのプリフィックス部分は無視され、純粋な型名の部分が暗黙的なフィールド名として利用されます。

    ということだがうまい例とか覚えてないと大失敗するとかそのへんの想像力が働かない

#### 無名構造体のとこで気になったやつ
* typeなくして<code>struct {フィールド定義}</code>としても使えるが使いみちがほぼ無い
* typeをstructと一緒につかう利用がここにある。すなわち無名構造体もできるっちゃできるから、である。structで定義した構造体にエイリアスをつけているだけ
* よいこのみんなはちゃんとtypeつけて名前をもたせようね

#### 構造体とポインタのとこで気になったやつ
* 構造体は値型なのでポインタつかえば参照渡しになってオブジェクト指向敵な使い方ができるね（早口
* 構造体を<code>&</code>つけて関数に渡す（関数では<code>*</code>つきで受取る）よりも、構造体のポインタを直接生成するほうが見通しがつきやすい
    ```
    //構造体を作ってそのポインタを生成
    p := Point{X: 3, Y: 4, Z: 5}
    somefunc(&p)   //めんどくさい（somefuncではp *Point）としてPointのポインタを受取る
    //最初からポインタを直接生成
    p := &Point{X: 3, Y: 4, Z; 5}
    somefunc(p)
    ```
#### newのとこで気になったやつ
* ポインタを生成するしくみとして*演算子をつかう手があるが、Goでは他言語でなじみぶかい<code>new</code>も使える
    ```
    p:=new(Point)
    ```
* ポインタを作るのと動作上の違いはほとんど無いのでどっちでもok
#### メソッドのとこで気になったやつ
* <b>OOPのメソッドとは意味が違う</b>らしい
* 結局似たようにつかうので認識上は同じと思っていい？
* 表記上はめっちゃわかりやすそう。funcとメソッド名の間に<b>レシーバー</b>の型とその名前を()でくくる
    * レシーバーがなんなのかについての説明はなされていない
    * <code>func (レシーバー名 レシーバーの型) 関数名(引数 引数の型) 戻り値 {処理}</code>
    * ふつうに引数と戻り値は省略可能
    ```
    //Point間の距離を求めるよくあるやつ
    func (p *Point) Dist(ap *Point) float64 {
        x, y := p.X-ap.X, p.Y-ap.Y
        return math.Sqrt(float64(x*x + y*y))
    }
	p := &Point{X: 3, Y: 10}
	p2 := &Point{X: 2, Y: 4}
	dist := p.Dist(p2)
	fmt.Println(dist)
    >>> 6.082762530298219
    ```
* レシーバーの型が異なっていれば同名のメソッドを定義可能
* <b>エイリアスを使えば基本型にもメソッドを定義できる</b>。互換性あるからなんかうまい具合に便利メソッド作れそう
    * 配列型のエイリアスを作って先頭/末尾の要素を返すやつとか
    * あと、ほら、lower_bound的なやつとか。。。
        * 作ってみるかと思ってソートを調べたらなんかインターフェースがどうたらとか言われてまだ速いなと思った次第
        * 代わりに累積和メソッドでお茶を濁す
        ```
        // この場合レシーバーに*は不要
        func (is Integars) RuisekiSum() []int {
            //ふつうにlenもrangeも使えるんですね
            res := make([]int, len(is))
            res[0] = is[0]
            sum := res[0]
            for i := 1; i < len(is); i++ {
                sum += is[i]
                res[i] = sum
            }
            return res
        }

        type Integars []int
        lis := Integars{-4, 2, 20, 5, -8, 3, 5, 2, 2, 4}
        fmt.Println(lis.RuisekiSum())

        >>> [-4 -2 18 23 15 18 23 25 27 31]
        ```
#### 型のコンストラクタのとこで気になったやつ
* コンストラクタは無いが型のコンストラクタならある（？
* 慣例的に<code>func New型名(フィールド フィールドの型, ...) 型のポインタ型{初期化処理;return 自分自身}</code>という感じで定義
    * なんかこの自分自身というかthisとかインスタンスとかの概念ないとなんていうのかわからんな
    ```
    //型のコンストラクタで初期化処理してみる
    type Yome struct {
        ID   int
        Name string
        Sex  int
        Tags []string
    }

    func NewYome(id int, name string) *Yome {
        //最初に自分自身のなんつーかインスタンス的なやつを作る
        y := new(Yome)
        y.ID = id
        y.Name = name
        y.Sex = 0
        y.Tags = []string{"ここに素晴らしい属性が入ります"}
        //で最後に返す
        return y
    }
    myyome := *NewYome(0, "谷川柑菜")
    fmt.Println(myyome)
    ```
#### 関数としてのメソッドのとこで気になったやつ
* > メソッドを関数型として参照するときには,「［レシーバーの型］.［メソッド］」のように書くことができます。
* > メソッドはレシーバーを第1引数としてとる単なる関数にすぎません。
* > メソッドを関数型として参照する場合にはもう1つ、「［レシーバー］.［メソッド］」という書き方もあります。
* <strong>わからん</strong>
#### スライスと構造体のところで気になったやつ
* 手を動かしたやつ[書いた](https://github.com/halllllll/startinggo/blob/master/chap5/struct3.go)
#### マップと構造体のとこで気になったやつ
* 構造体はマップのキーあるいは値に指定できる
* リテラルで作るときはその際構造体名を省略できる
    * ただしmakeで作ったやつだとダメだった
    ```
    type Friends struct{
        Name string
        Serif string
    }
    //リテラルで作る
    m1:=map[Friends]int{
        {Name: "サーバル", Serif:"食べないよ!!"}:100,
        {Name: "タイリクオオカミ", Serif: "いい顔いただきました"}:10000,
    }
    //キーと値を逆にしただけ
    m2:=map[int]Friends{
        100:{Name: "サーバル", Serif:"食べないよ!!"},
        1000:{Name: "タイリクオオカミ", Serif: "いい顔いただきました"},
    }

    // ただし以下のようにmakeで作る場合は構造体名は省略できない
    m3:=make(map[Friends]int)
    m3[Friends{Name: "フェネック", Serif:"ああああああああらいさーーーーーーん♡♡♡♡♡♡♡♡♡♡♡♡♡♡♡♡"}]=1919
    m3[Friends{Name: "カバ", Serif: "全員ぶっ殺してやる"}]=-1
    ```
#### タグのとこで気になったやつ
* タグとは、構造体のフィールドに付加するメタ情報のこと
* <code>フィールド名 型名 "タグ名"</code>またはraw文字列で<code>フィールド名 型名 `タグ名`</code>という感じで、フィールドの最後に指定する
    * <b>ふつうraw文字列のほうが好まれるらしい</b>
* （教科書で言及されているだけでなく）ggってみるとこれはわりと<code>json</code>を使う場面で使うシチュエーションがあるっぽい
    > jsonパッケージを利用すると、構造体型などのデータ構造をJSON形式 のテキストに簡単に変換することができます。また、jsonパッケージは、与えられた構造体のフィールドのタグ内にjson:"［キー名］"という形式の文字列を見つけると、自動的にその情報を拾い出して、出力するJSONテキストのキー名として利用し ます。このようにタグは、プログラムやライブラリに対してのメタ情報として機能します。
* 試したところ、構造体のフィールドの頭文字は大文字じゃないとちゃんとjsonに認識してもらえなかったので注意。こんなクソみたいなところでサンプルコードごときに4時間足掛け2日かかったのまじでクソ

### インターフェース
* Goにおけるインターフェースとは
    * 型の柔軟性を担保する機能
    * 型の一種
    * Javaとかのインターフェースと同じ感じでいい
    * > メソッドセットの定義をもとにしてさまざまな型を総称するための仕組みです。
    * つまり早い話が<strong>実装するとこんなのが使えるように鳴るよっていうメソッドを詰め合わせた型</strong>ってことでいいのかな（知らん
    * > インターフェースのメソッドを外部に隠ぺいすることで得られるメリットはほとんど考えられないので、原則的には外部から参照可能なメソッドのみを定義するべきでしょう。

        とあるが、なんで考えられないのかすら考えられない。わからん
    * インターフェースにインターフェースを含むように定義できるので多重に実装できる。もちろんすべてのメソッドを実装する必要がある
        * わかりにくくなることは明々白々なので無視
* <code>type interface インターフェース名</code>という感じ
#### errorのとこで気になったやつ
* 代表的な組込みインターフェースらしい
* わりとどこでも見かけるらしい
* 文字列を返すメソッド<code>Error</code>のみが定義されている
    ```
    type error interface{
        Error() string
    }
    ```
* テストとしてやったやつ。ちょっとみてくれわからんけど [これ](https://github.com/halllllll/startinggo/blob/master/chap5/error.go)
#### インターフェースのメリットのとこで気になったやつ
* 異なる型に共通の処理を付与できる
    * もちろんすべての型（構造帯）にちゃんと同名のメソッドをあらかじめ加えておかねばならんけど。これまで出てきた範疇に限って考えれば（そもそもほかに方法があるのか、もっと良い書き方があるのかは知らん）。
* 特定のインターフェース型の変数を受け取ってなんか処理する関数を作り、そこに同じインターフェースをもつ構造体っつーか構造体のポインタっつーかインスタンスを投げ込めば一様に処理できる（わかりづらいので書いたやつ参照 [ここ](https://github.com/halllllll/startinggo/blob/master/chap5/interface1.go)）

#### fmt.Stringerのとこで気になったやつ
* fmtパッケージに定義されている組込みのインターフェースでstring型を返すString()なる関数をひとつだけ有する
    ```
    type Stringer interface{
        String() string
    }
    ```
* 任意の型の文字列表現をカスタマイズできるらしい。べつにほかのメソッドに「Stringerつかうよ」的な設定なしで、ただ単にStringを実装すれば勝手にfmtパッケージの出力で整形してくれるらしい。[ここ](https://github.com/halllllll/startinggo/blob/master/chap5/stringer.go)

#### itnerface{}の本質のとこで気になったやつ
* わからん。。。なんも。。。。
* どうやらinteface{}型は<b>実装すべきメソッドが1つも定義されていないインターフェース</b>というのが結論らしき体で書かれているが、なんのことやら
* 無視しよう

### まとめ

* 関数で配列のポインタ型を扱う場合は<code>(*ptr)[i]</code>というふうに括弧でくくっちまうのはCとかいう野蛮な言語を操る連中で、Goではそのまま書いても配列の要素の参照に展開してくれる
* newあるんですね
* 構造体はフィールドを非公開に、メソッドは公開にすれば隠蔽性が高くてメンテナンス的にもgood（二回目