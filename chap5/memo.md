## 構造体とインターフェース
* <code>struct</code>と<code>interface</code>について
### ポインタ
#### ポインタの定義のとこで気になったやつ
* Goにおけるポインタは<code>*int</code>みたいな表記で表す。つまりよくある感じのやつ
* Goでは<code>*[4]float64</code>みたいな感じで、「要素数4でfloat型配列のポインタ型」という感じ
    * ただしスライスとかマップとかチャネルはそもそも参照型なのでポインタ型で表してもとくに意味はない（書くことはできる）
* GOでは定義のみを行ったポインタは<code>nil</code>になる
* ポインタのポインタもできるけどGoでつかうことはまずない
#### アドレス演算子とデリファレンスのとこで気になったやつ

* アドレス演算子<code>&</code> まあこれもよくあるふつうのアドレス演算子と同じ
* 任意の型からそのポインタ型を生成できる
    ```
	var i int
	ptr := &i
	fmt.Printf("%T\n", ptr)	//intのポインタ型
	ptrptr := &ptr
	fmt.Printf("%T\n", ptrptr) //intのポインタのポインタ型
    ```
* ポインタ型の変数から値を参照したり（デリファレンス）操作したりする。このへんもよくあるふつうの仕様と同じ
    ```
	i = 5
	fmt.Println(*ptr) //ポインタ型変数ptrの参照先
	*ptr *= 2         //そのまんま直接操作もできる
	fmt.Println(i)
    ```
* 関数にアドレスを渡すやつ。これもよくあるry
    ```
    ii := 1
    pp := &ii
    some(pp)
    fmt.Println(ii, *pp)

    // intのポインタ型を受け取って直接操作する
    func some(i *int) {
        *i *= 999
    }
    >>> 999 999
    ```
* Goでは配列が値型ゆえポインタ型で操作すればもとの配列もいじれる
    ```
    arry := [3]int{1, 2, 3}
    ary_bai(&arry)
    fmt.Println(arry)
    ary_bai(&arry)
    fmt.Println(arry)
    ary_bai(&arry)
    fmt.Println(arry)

    // [3]intの配列のポインタ型を受け取って操作する
    func ary_bai(ap *[3]int) {
        for i := 0; i < 3; i++ {
            // 演算子によっては計算順序の違いからエラーをくらうことになる（* がポインタ演算子か乗算かの区別がつかない）ので()でくくってデリファレンスであることを明示する
            (*ap)[i] *= (*ap)[i]
            //ただしGoでは自動的に配列の要素の参照であると判断してくれるらしいのでこれでもいい
            ap[i] *= ap[i]
        }
    }
    >>> [1 4 9]
    >>> [1 16 81]
    >>> [1 256 6561]
    ```
    コード内にも書いたように、Goでは<code>(*p)[i]</code>のような書き方をしなくても<code>p[i]</code>だけでいい
    * lenやcapやスライス式でも同じく
    * rangeも同じく
    ```
	strings := [3]string{"smoke", "weed", "everyday"}
	stp := &strings
	fmt.Println((*stp)[0], stp[0], strings[0])
    //ほんとは二番目のやつはイレギュラーだがGoではコンパイラが自動的にデリファレンスからの配列の要素の参照だと判断してくれる
	for i, v := range stp {
		fmt.Println(i, v)
	}
    ```
### まとめ
* 関数で配列のポインタ型を扱う場合は<code>(*ptr)[i]</code>というふうに括弧でくくっちまうのはCとかいう野蛮な言語を操る連中で、Goではそのまま書いても配列の要素の参照に展開してくれる