#### カンマのとこで気になったやつ
* Goでは文末？文端？でコンパイラが自動的に<code>;</code>を付けて文の終わりとみなす
* なので、  
<code>
	cities:=[]string{</br>
        "tokyo",</br>
        "paris",</br>  
        "Roma",</br>  
        "Sri Jayawardenepura Kotte" </br>
	}  
</code>は最後の要素に<code>;</code>がつけられてしまい構文エラーとなる

#### fmtパッケージのとこで気になったやつ
* fmt.Printf
    * よく出てきたけど書式指定子を使える。フォーマット文字列。
    * <code>fmt.Printf("I'm %d years old.", 100)</code>みたいな
    * 書式指定子、まったく覚えられんまま十進数とか文字とかだけ知ってりゃどこでも使えるやろとヘラヘラしてたんだけどGoだと<code>%v</code>とか<code>%#v</code>とか特殊なのが出てくるのよ
    * 
        | 書式指定子 | 意味 |
        |:------------:|:------------|
        | %d | 10進数(decimal) |
        | %b | 2進数(binary) |
        | %o | 8進数(octal) |
        | %h | 16進数(hexadecimal) |
        | %f | 浮動小数点数 |
        | %e, %g | 指数とか複素数<br>違いがよくわからん、どちらも両方使える |
        | %s | string |
        | %v | デフォルトフォーマット<br>いろんな型を読み込める |
        | %#v | Goのリテラルで表現 |
        | %T | 型情報 |
    など。他は[golang.jp - fmt パッケージ](http://golang.jp/pkg/fmt)参照

#### print, printlnのとこで気になったやつ
* 標準出力じゃなくて標準エラー出力
* VSC上はどちらも出力コンソールに表示されるしどういうことかはよくわからんが
* 型が「変数型」「値型」「ポインタ型」の3つに分類されるのってけっこう特殊な気がするんだけどCとかってそうなのかな

#### 変数定義の詳細のとこで気になったやつ
* Goの変数は関数内で定義されるローカル変数とパッケージに依存するパッケージ変数の二種類
    * パッケージ変数はプログラムのどこからでも参照可能なので実質グローバル変数なのではないか
    * （言語仕様上はグローバル変数は定義されていないらしい？）
    * つまり、所属するパッケージ内で定義された（ローカル変数でない、関数スコープの外で定義された）変数はそのパッケージに依存するどのプログラムからも参照可能ってことか
    * やってみた（さっそくビルドの仕方を忘れていた。。<code>go run 同じパッケージを定義しているすべてのgoファイルを列挙</code>で通る）[これ](https://github.com/halllllll/startinggo/tree/master/chap3/variabledifinite_sample)

#### 数値型のとこで気になったやつ
* byte型==int8型。どちらでもいいんかい（そりゃそうだが。。。）
* 実装依存の整数型
    * 32bitなGoか(<code>int</code>)64bitなGoか(<code>uint</code>)、あとOSによってはポインタを整数にするときにどのくらいの大きさになるかわからんので<code>uintptr</code>型なんてのもあるらしい
    * 書いたけどぜんぜんわかってない
* 8進数のリテラルが単に0をつけただけの<code>0393</code>みたいな感じで表される
    * どっかでハマりそう
* 符号なし整数値にするには明示的なキャストが必要
    * ふつうに整数リテラルで定義したんじゃintかuintかわからんもんね（仕様上intに収まるらしい

#### 浮動小数点型のとこで気になったやつ
* 明示的に宣言しない限りfloat64型になる

#### 複素数型のとこで気になったやつ
* <code>complex64</code>型と<code>complex128</code>型で、前者が実部・虚部に32bitずつ、後者は64bitずつ
* リテラルに則って定義するか、complex関数が組込みで存在する。戻り値はcomplex128

#### rune型のとこで気になったやつ
* 厨二
* int32型と同じ
* シングルクォートで囲まれたUnicode文字
    * すべてのUnicode文字を単一の型で表そうとしている？32bitありゃたぶん間に合うだろって感じ

#### RAW文字リテラルのとこで気になったやつ
* バッククォート``で囲むとRAW文字になる

#### 配列型のとこで気になったやつ
* 要素数の省略。<code>arr:=[...]int {1, 2, 4, 8}</code>
* 要素数が異なれば別の型になる<br>
<code>
	ar1 := [3]string{"カバさん", "アリクイさん", "あんこう"}<br>
	ar2 := [5]string{"うさぎさん", "カメさん", "レオポンさん", "カモさん", "アヒルさん"}<br>
	ar1type, ar2type := reflect.TypeOf(ar1), reflect.TypeOf(ar2)<br>
	if ar1type != ar2type{<br>
		fmt.Println(ar1type, ar2type)<br>
	}
</code>
* 値型（!!!!!!!!!!!!!）

#### interfaceとNilのとこで気になったやつ
* <code>var x interface{}</code>で定義
* object型みたいなもんらしい
    * なんでも代入できる
* 初期値Nil
* 詳しくはあとでやるっぽい

### 関数
* Goは非オブジェクト指向
* OOPでいうところのメソッドはGoで使われるメソッドと意味が異なるらしい　よくわからんが
#### 関数型のとこで気になったやつ
* 
#### エラー処理のとこで気になったやつ
* <b>Goには例外機構がない</b>。関数が複数の戻り値を返すことができるのでそれを利用する
* 戻り値で<code>err</code>とするのはGoのイディオム
    * たとえば<code>if(err!=Nil)</code>などとしてエラーが発生したかどうかを判断する
#### 無名関数のとこで気になったやつ
* lambda式的な
* 関数を値のように扱うことで、引数に関数をとる関数や関数を返す関数とか作れる


### まとめ
* ここでやっと書籍内の書式について出て来るの新しい。こっからが本番だという気持ち
* <code>Println</code>のほかにデバッグ用に<code>println</code>があるだなんて
* python的に右辺の配列を左辺の複数の変数に暗黙的にアンジップして代入できないかとかやったけどダメみたいですね( startinggo/chap3/variable_sample1.go )
* パッケージ変数とかいう新概念（ただの名前空間）
* rune型はUnicodeを単一の型でがんばって表そうとしている（?
* 要素数ゼロの配列とか作れる