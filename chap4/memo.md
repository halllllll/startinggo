## 参照型とは
* よくある参照型の認識で構わない？
* goではスライス、マップ、チャネルのデータ構造が標準で相当する
### make関数
* スライス、マップ、チャネルはいずれも<code>make</code>関数によって作成される。
### スライス
* いちばん使うデータ構造。可変長配列のための型みたいなもん
* <code>s:=make([]int, 10)</code>という感じ。要素数10のint型のスライス
* 容量を指定する場合は
    ```
    s:=make([]int, 5, 10)
    ```
    という形。 これで要素数5, 容量10のスライスが定義される（後述）
* また、配列ライクに定義することも可能。この場合は要素数=容量となる
    ```
    s:=[]int{1, 2, 3, 4, 5}
    ```
* 見た目はあまり配列と変わらん。配列数が表示されるかどうか
    * <code>reflect.TypeOf</code>や<code>fmt.Prinltf("%#v", slice)</code>で型を表示
* 代入も参照も配列と同じ文法で実現できる
    * スライスの要素数を超過した要素へのアクセスはパニックを起こす
    * <code>panic: runtime error: index out of range</code>
* <code>len</code>で要素数を得られる
* <code>cap</code>で容量capacityを得られる
* 容量はスライスが将来使うかもしれない領域を予め確保しておいたもの
    * 可変長配列とはいえGo的には新たにメモリ領域を確保し直すのは負荷が高い処理らしい
    * したがって予めどの程度の容量が必要になるかの見積もりもパフォーマンスのためには必要
* 配列やスライスをもとにして新たなスライスを作ることができる。<b>簡易スライス式</b>とかいうらしい
    ```
    array:=[5]int{10, 4, 2, -5, 3}
    slice:=array[2:]
    ```  

* 簡易スライス式は文字列にも使えるが、配列のとこでやったように<b>文字列をバイト列としてみなしたうえでのインデックスを指定する必要がある</b>。utf8だと日本語は１文字につき3byte必要なので3区切りのインデックスを指定してやらねばならない
* <code>append</code>でスライスを拡張する
    * <code>newslice := append(slice, sliceの要素型の要素1, 要素2, ....)</code>
    * また、スライス同士の結合も可能。その場合は第二引数の末尾に...をつける
    ```
    slicea := make([]int, 4)
	sliceb := []int{3, 3, 0}
	slicec := append(slicea, sliceb...)
	fmt.Println(slicec, cap(slicec))
    >> [0 0 0 0 3 3 0] 8
    ```
    ちなみに3つ以上のスライスの結合はどうやるのかわからんしできるとも限らない

#### copyのとこで気になったやつ
* スライスにスライスの値をコピーするときの組み込み関数
    ```
    slicea := make([]int, 4)
    sliceb := []int{3, 3, 0}
    n := copy(slicea, sliceb)
    fmt.Println(n, slicea)
    >> 3 [3 3 0 0]
    ```
    戻り値はなぜか<b>「コピーされた要素数」</b>であることに注意。実際には第一引数のスライスに第二引数のスライスを上書きコピーする。
* コピー先の要素数のほうが大きい場合はそのまま先頭から順にコピーされるだけだが、逆にコピー元のほうが大きい場合はコピー先の容量を越えて増えることはない。上のコードでsilceaとslicebを逆にしてcopyすると
    ```
    >>> 3 [0 0 0]
    ```
    になる
#### 完全スライス式のとこで気になったやつ
* 配列やスライスからスライスを作るときにその容量をコントロールする
* 通常、要素10容量10の配列またはスライスから簡易スライス式を使って部分スライス[2:4]を抽出すると要素数2, 容量8のスライスになる
    ```
    関係: 0<=low<=high<=max<=cap(もとの配列またはスライス)
    完全スライス式: a[low:high:max]（aは配列またはスライス）
    簡易スライス式: a[low:high]

    ①簡易スライス式で新たに作られたスライスの容量=len(a)-low
    ②完全スライス式で新たに作られたスライスの容量=max-low
    ```
    すなわち、①より、要素10容量10から[2:4]として抽出たスライスの容量は10-2=8となる。
    完全スライス式で作るときはこの8を越えない範囲で容量の最大値を指定できるというわけ
* 教科書の図を見たほうが速い

#### スライスとforのとこで気になったやつ
* rangeを使った範囲節for。配列とおなじ
    * スライスの各要素に対して操作を行うようなループだと、たとえばループの条件節に要素数をiが越えないみたいな感じにしたうえでループ内でappendしたりすると無限ループになる（わかりにくい
    * rangeを使ったループだとそういうことにはならない。rangeの場合はループ開始時点での要素数を対象とするのでスライスをループ内で変更しても影響はない（わかりにくい
* 要は、<b>スライスをループしたいときはrangeを用いた範囲節forでやれ</b>ということ

#### スライスと可変長引数のとこで気になったやつ
* <code>fmt.Printf()</code>とかは可変長引数、それにスライスが使われている
* 可変長引数をとる関数
    ```
    func sum(slices ...int)int{
        // ぜんぶ足すだけ
        ans:=0
        for _,v := range slices{
            ans+=v
        }
        return ans
    }
    ```
    <code>slices ...int</code>のように型名の前に<code>...</code>をつけているところがポイント。
* 可変長引数は引数の最後にひとつだけ指定できる。pythonと似たようなもん
* スライスを可変長引数に渡す場合は変数名の前に<code>...</code>をつける
    ```
    //スライスを可変長引数として使う
    integers:=[]int{4, 2, 3, 6, 0, 10, -20}
    fmt.Println(sum(integers...))
    ```
#### 参照型としてのスライスのとこで気になったやつ
* 基本的にはごく普通のいわゆる参照型の扱いとおなじでいい
* Goに特徴的な基本型と参照型の違いは、<b>nilを値として取りうるかどうか</b>である、らしい
    * と思ったけどべつにGoに特徴的ってことはないな
#### スライスの落とし穴のとこで気になったやつ
* 配列からスライスを抽出する場合、コピーではなくそのまま配列の要素を参照する。よってこの段階で配列の要素に代入したりするとスライスのほうもその影響を受ける
* ただし、appendによる拡張などによって新たにメモリ領域が割り当てられ、スライスの参照先が変化した場合、当然もとの配列を操作してももうスライスには影響しない
* あーいわれてみれば確かに、という挙動。要注意

### マップ
* 連想配列
* makeを使って生成する場合
    ```
    m:=make(map[int]string)
    ```
    int型をキーに、string型を値にもつマップ,となる
#### マップのリテラルのとこで気になったやつ
* 宣言
    ```
	m2:=map[int]string{1: "富士", 2: "鷹", 3: "ダーーーーーーッ!!!!"}
	m3:=map[int]string{
		10: "眠い",
		21: "だるい",
		32: "死にたい",	//, 必須
	}
    ```
    という感じで作れる。ふたつめのやつで最後にカンマをつけないと<code>unexpected newline, expecting comma or }</code>って怒られる
#### 要素の参照とのとこで気になったやつ
* ふつうに変数名[キー]で値にアクセスできる
* 存在しない値へアクセスしようとすると、変数名[キー]の段階で初期値が与えられてしまう
    ```
	//存在しない値にアクセスすると値が初期化され定義される
	v1 := m3[1000]
	fmt.Println(v1=="")
    >>> true
    ```
* という問題があるので、次のようにする
    ```
	v2, ok := m3[10]
	fmt.Println(v2, ok)
    >>> 眠い true
	v3, ok := m3[999]
	fmt.Println(v3, ok)
    >>>  false
    ```
* Goのマップは値にnilを指定できる。値が参照型であるようなマップを取り扱うときは要注意
    * なのでokイディオムを使うやつを積極的に多用する
* <b>lenが使える</b>。地味に便利そう
* 消すときは組み込み関数<code>delete</code>を使う。
    ```
    delete(マップ, キー)
    ```
    ちなみにキーが存在しなくてもとくにエラーは吐かない
* 容量の概念はないが、makeを使って生成するときに第二引数に「だいたいこんくらいの要素必要っぽい」って整数を与えてやるとランタイムに優しいらしい
    * 少ない要素数では無意味らしいけど

#### マップとforのとこで気になったやつ
* rangeを使って範囲節forをかける
    * 配列や文字列やスライスだとrangeから返るのはインデックス、値という順番だが、マップではキー、値という感じ
* 当然ながら順序は保証されない
### まとめ
* スライスは可変長配列
* スライスは要素数と容量という概念を持つ
* 容量を越えた範囲でスライスを拡張しようとすると、自動的に容量を増やして確保してコピーする
    * これはなかなかコストが高い処理
* スライスをループするときはrange使え
* appendで拡張したときに参照先変わるよ
* Goのマップは値にnilを指定できる。値が参照型であるようなマップを取り扱うときは要注意（二回目