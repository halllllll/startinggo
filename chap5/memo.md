## 構造体とインターフェース
* <code>struct</code>と<code>interface</code>について
### ポインタ
#### ポインタの定義のとこで気になったやつ
* Goにおけるポインタは<code>*int</code>みたいな表記で表す。つまりよくある感じのやつ
* Goでは<code>*[4]float64</code>みたいな感じで、「要素数4でfloat型配列のポインタ型」という感じ
    * ただしスライスとかマップとかチャネルはそもそも参照型なのでポインタ型で表してもとくに意味はない（書くことはできる）
* GOでは定義のみを行ったポインタは<code>nil</code>になる
* ポインタのポインタもできるけどGoでつかうことはまずない
* というかそもそもCと比べてポインタをつかうシチュエーションが限られている
#### アドレス演算子とデリファレンスのとこで気になったやつ

* アドレス演算子<code>&</code> まあこれもよくあるふつうのアドレス演算子と同じ
* 任意の型からそのポインタ型を生成できる
    ```
	var i int
	ptr := &i
	fmt.Printf("%T\n", ptr)	//intのポインタ型
	ptrptr := &ptr
	fmt.Printf("%T\n", ptrptr) //intのポインタのポインタ型
    ```
* ポインタ型の変数から値を参照したり（デリファレンス）操作したりする。このへんもよくあるふつうの仕様と同じ
    ```
	i = 5
	fmt.Println(*ptr) //ポインタ型変数ptrの参照先
	*ptr *= 2         //そのまんま直接操作もできる
	fmt.Println(i)
    ```
* 関数にアドレスを渡すやつ。これもよくあるry
    ```
    ii := 1
    pp := &ii
    some(pp)
    fmt.Println(ii, *pp)

    // intのポインタ型を受け取って直接操作する
    func some(i *int) {
        *i *= 999
    }
    >>> 999 999
    ```
* Goでは配列が値型ゆえポインタ型で操作すればもとの配列もいじれる
    ```
    arry := [3]int{1, 2, 3}
    ary_bai(&arry)
    fmt.Println(arry)
    ary_bai(&arry)
    fmt.Println(arry)
    ary_bai(&arry)
    fmt.Println(arry)

    // [3]intの配列のポインタ型を受け取って操作する
    func ary_bai(ap *[3]int) {
        for i := 0; i < 3; i++ {
            // 演算子によっては計算順序の違いからエラーをくらうことになる（* がポインタ演算子か乗算かの区別がつかない）ので()でくくってデリファレンスであることを明示する
            (*ap)[i] *= (*ap)[i]
            //ただしGoでは自動的に配列の要素の参照であると判断してくれるらしいのでこれでもいい
            ap[i] *= ap[i]
        }
    }
    >>> [1 4 9]
    >>> [1 16 81]
    >>> [1 256 6561]
    ```
    コード内にも書いたように、Goでは<code>(*p)[i]</code>のような書き方をしなくても<code>p[i]</code>だけでいい
    * lenやcapやスライス式でも同じく
    * rangeも同じく
    ```
	strings := [3]string{"smoke", "weed", "everyday"}
	stp := &strings
	fmt.Println((*stp)[0], stp[0], strings[0])
    //ほんとは二番目のやつはイレギュラーだがGoではコンパイラが自動的にデリファレンスからの配列の要素の参照だと判断してくれる
	for i, v := range stp {
		fmt.Println(i, v)
	}
    ```
* <code>fmt.Printf()</code>で書式指定子<code>%p</code>を使えば実際のアドレス値がわかる。べつにわかんなくて困るシチュそんなでくわさない

#### 文字列とポインタのとこで気になったやつ
* Goではstringがイミュータブルなので、string型の要素であるbyte型をポインタでいじろうとするとエラーを起こす
    * stringを参照渡しするようなシチュは基本的に存在しない
### 構造体
* Goにはクラスとか無いよ
#### typeのとこで気になったやつ
* <code>type 定義する型 既存の方</code>みたいな感じ
* （型の）エイリアスとか作る。競プロerの<code>#define ll long long</code>みたいな感じ
* 関数もエイリアス作れる
    * 書いたサンプルがなぜか動かずわけわからんくなったので無視
* まとめて定義できる。
    ```
    //typeでまとめてエイリアスを定義
    type (
        i_pair [2]int
        rgba   [3]float64
        i_chan chan int
        s_chan chan string
    )

    func main() {
        pair := i_pair{-1, 3}
        col := rgba{0.334, 0.233, 0.734}
        fmt.Println(pair, col)
    }
    ```
* 同じ型をベースにした異なる型のエイリアスをtypeでを作ってもベースにした型とは互換性があるが別のエイリアスとは互換性がない
    * つまりintからtypeで２つの型T0,T1を作ったとき、T0+10とかはできるがT0-T1とかはできない（型にオペレーターが定義されていない？）
#### 構造体の定義のとこで気になったやつ
* <code>type 構造体名 struct {フィールドの定義}</code>>という感じ。structだけで定義できるようにしたほうがいいんじゃないの？？と思わんでもない（structつかうときどうせかならずtypeが必要になるの邪魔くさい）

### まとめ
* 関数で配列のポインタ型を扱う場合は<code>(*ptr)[i]</code>というふうに括弧でくくっちまうのはCとかいう野蛮な言語を操る連中で、Goではそのまま書いても配列の要素の参照に展開してくれる