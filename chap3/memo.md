#### カンマのとこで気になったやつ
* Goでは文末？文端？でコンパイラが自動的に<code>;</code>を付けて文の終わりとみなす
* なので、  
<code>
	cities:=[]string{</br>
        "tokyo",</br>
        "paris",</br>  
        "Roma",</br>  
        "Sri Jayawardenepura Kotte" </br>
	}  
</code>は最後の要素に<code>;</code>がつけられてしまい構文エラーとなる

#### fmtパッケージのとこで気になったやつ
* fmt.Printf
    * よく出てきたけど書式指定子を使える。フォーマット文字列。
    * <code>fmt.Printf("I'm %d years old.", 100)</code>みたいな
    * 書式指定子、まったく覚えられんまま十進数とか文字とかだけ知ってりゃどこでも使えるやろとヘラヘラしてたんだけどGoだと<code>%v</code>とか<code>%#v</code>とか特殊なのが出てくるのよ
    * 
        | 書式指定子 | 意味 |
        |:------------:|:------------|
        | %d | 10進数(decimal) |
        | %b | 2進数(binary) |
        | %o | 8進数(octal) |
        | %h | 16進数(hexadecimal) |
        | %f | 浮動小数点数 |
        | %e, %g | 指数とか複素数<br>違いがよくわからん、どちらも両方使える |
        | %s | string |
        | %v | デフォルトフォーマット<br>いろんな型を読み込める |
        | %#v | Goのリテラルで表現 |
        | %T | 型情報 |
    など。他は[golang.jp - fmt パッケージ](http://golang.jp/pkg/fmt)参照

#### print, printlnのとこで気になったやつ
* 標準出力じゃなくて標準エラー出力
* VSC上はどちらも出力コンソールに表示されるしどういうことかはよくわからんが
* 型が「変数型」「値型」「ポインタ型」の3つに分類されるのってけっこう特殊な気がするんだけどCとかってそうなのかな

#### 変数定義の詳細のとこで気になったやつ
* Goの変数は関数内で定義されるローカル変数とパッケージに依存するパッケージ変数の二種類
    * パッケージ変数はプログラムのどこからでも参照可能なので実質グローバル変数なのではないか
    * （言語仕様上はグローバル変数は定義されていないらしい？）
    * つまり、所属するパッケージ内で定義された（ローカル変数でない、関数スコープの外で定義された）変数はそのパッケージに依存するどのプログラムからも参照可能ってことか
    * やってみた（さっそくビルドの仕方を忘れていた。。<code>go run 同じパッケージを定義しているすべてのgoファイルを列挙</code>で通る）[これ](https://github.com/halllllll/startinggo/tree/master/chap3/variabledifinite_sample)

#### 数値型のとこで気になったやつ
* byte型==int8型。どちらでもいいんかい（そりゃそうだが。。。）
* 実装依存の整数型
    * 32bitなGoか(<code>int</code>)64bitなGoか(<code>uint</code>)、あとOSによってはポインタを整数にするときにどのくらいの大きさになるかわからんので<code>uintptr</code>型なんてのもあるらしい
    * 書いたけどぜんぜんわかってない
* 8進数のリテラルが単に0をつけただけの<code>0393</code>みたいな感じで表される
    * どっかでハマりそう
* 符号なし整数値にするには明示的なキャストが必要
    * ふつうに整数リテラルで定義したんじゃintかuintかわからんもんね（仕様上intに収まるらしい

#### 浮動小数点型のとこで気になったやつ
* 明示的に宣言しない限りfloat64型になる

#### 複素数型のとこで気になったやつ
* <code>complex64</code>型と<code>complex128</code>型で、前者が実部・虚部に32bitずつ、後者は64bitずつ
* リテラルに則って定義するか、complex関数が組込みで存在する。戻り値はcomplex128

#### rune型のとこで気になったやつ
* 厨二
* int32型と同じ
* シングルクォートで囲まれたUnicode文字
    * すべてのUnicode文字を単一の型で表そうとしている？32bitありゃたぶん間に合うだろって感じ

#### RAW文字リテラルのとこで気になったやつ
* バッククォート``で囲むとRAW文字になる

#### 配列型のとこで気になったやつ
* 要素数の省略。<code>arr:=[...]int {1, 2, 4, 8}</code>
* 要素数が異なれば別の型になる
```
	ar1 := [3]string{"カバさん", "アリクイさん", "あんこう"}
	ar2 := [5]string{"うさぎさん", "カメさん", "レオポンさん", "カモさん", "アヒルさん"}
	ar1type, ar2type := reflect.TypeOf(ar1), reflect.TypeOf(ar2)
	if ar1type != ar2type{
		fmt.Println(ar1type, ar2type)
	}
```

* 値型（!!!!!!!!!!!!!）

#### interfaceとNilのとこで気になったやつ
* <code>var x interface{}</code>で定義
* object型みたいなもんらしい
    * なんでも代入できる
* 初期値Nil
* 詳しくはあとでやるっぽい

### 関数
* Goは非オブジェクト指向
* OOPでいうところのメソッドはGoで使われるメソッドと意味が異なるらしい　よくわからんが
#### 関数型のとこで気になったやつ
* 
#### エラー処理のとこで気になったやつ
* <b>Goには例外機構がない</b>。関数が複数の戻り値を返すことができるのでそれを利用する
* 戻り値で<code>err</code>とするのはGoのイディオム
    * たとえば<code>if(err!=Nil)</code>などとしてエラーが発生したかどうかを判断する
#### 無名関数のとこで気になったやつ
* lambda式的な、あるいはジェネレータ的な
* 実際はクロージャらしい
* 関数を値のように扱うことで、引数に関数をとる関数や関数を返す関数とか作れる
* 関数を返す関数
```
//string型の引数を受け取って戻り値のない関数を返す関数
func retfunc(a string) func(){
    return func(){
       fmt.Println(a)
    }
}
//string型の引数を受け取って「string型を返す関数」を返す関数
func retfunc2(a string) func()string{
	return func()string{
		return a+"!!!!!!!!!!!"
	}
}
```
* 関数を引数にとる関数
```//戻り値のない関数を引数にとる戻り値のない関数<br>
func callfunc(f func()){
	f()
}
func main(){
	callfunc(func(){fmt.Println("わかりづらい")})
}
```

* クロージャとして使える。内部関数（Goではそのような言い方をされるのかは知らんが）から外部関数のローカル変数を参照することで、本来実行語に消去されるローカル変数を保ちつづける

### 定数
* <code>const</code>キーワードで定数を定義できる
* まとめて定義するときは最初に定義したものが自動的にあとから宣言した変数に代入される
* 式も書ける。ほかで定義されている定数も含めることができる
* <b>基本型の整数型と定数の整数値は本質的に異なる</b>。型あり定数は明示的に<code>const I int64=100</code>などと定義される。
    * あるいは<code>const I = (int64)100</code>のほうがわかりやすい
* 定数同士の演算はコンパイル時に処理される

#### iotaのとこで気になったやつ
* 列挙子など存在しないが、こいつを使えば実現できる
* >iotaは参照の有無によらずconstブロックの中で定数が定義されるたび に1ずつ増分します。カウンターのようなイメージではなく、定数群に付与されたインデックスとしてイメージするほうがより適切かもしれません。

#### 識別子のとこで気になったやつ
* 変数名、関数名、定数名はGoにおいては<b>識別子</b>とされる。
* （つまりどういうことだってばYOO）

### スコープ
* Goにおけるスコープ、大きい単位から順に、<b>パッケージ</b>, <b>ファイル</b>, <b>関数</b>, <b>ブロック</b>, <b>制御構文</b>
* 変数、関数、定数、型はすべてパッケージに属する
#### パッケージのスコープのとこで気になったやつ
* パッケージに定義された識別子がほかのパッケージから参照できるかどうかは<b>識別子の1文字目が大文字であるかどうか</b>で決定される
    * Chap2でハマったところ回収
* 参照先の（ほかのパッケージの）関数が同じパッケージのほかの識別子を参照している場合はもうそこで既に関数にアクセスできているので大文字とか関係なくふつうにそのまま参照できる
#### importの詳細のとこで気になったやつ
* パッケージ名を上書きして任意の名前で呼べる。
    * <code>import f "fmt"</code>みたいな感じ
* パッケージ名を省略できる
    * <code>import . "math"</code>みたいな感じ
    * ただし識別子の衝突に注意。重複した名前を定義するとコンパイルエラーとなる
#### ファイルのスコープのとこで気になったやつ
* 同一パッケージに複数ファイルが含まれる（==複数ファイルでひとつのパッケージを定義している）場合、importはそれぞれのファイル内でのみ有効となり独立する
#### 関数のスコープのとこで気になったやつ
* これはよくあるプログラミング言語の仕様どおりでふつうの関数内スコープ
* 引数や戻り値も識別子のうちなので重複して定義はできない
    * <code>{}</code>がスコープの区切りなので別のスコープの内部だったら大丈夫。つまり関数より深いブロックだったらおｋ
    * まあ重複なんてややこしいからやるなってこった

### 制御構文
* いろんな書き方がある
#### ifのとこで気になったやつ
* <code>{}</code>は省略不可能で、かならずブロックを明示的に書く
* 条件式は<b>かならず論理値で評価する。</b>1がtrueになったり空配列がfalseになったりはしない
* 簡易文を使って条件式に使う変数を定義したりできる<br>
    <code>if x,y:=1,2; x<y{}</code>的な感じ
#### forのとこで気になったやつ
* whileはないけど条件付きforで同じことをできる
* よくあるforの初期化文、条件文、後処理文はいずれも省略可能だし全部なくてもいい（無限ループになる）
* <code>range</code>と一緒に使うのがわりと有用そうだし頻度高そう
    * <code>for idx, v:=range 配列とかマップとか文字列みたいなデータ構造:</code>みたいな感じ
    * 順番はpythonのenumerateと同じでインデックス、要素みたいな感じ
* 配列とスライスとマップとかのコレクションだけでなく文字列やチャネルにも使える
    * マップもpythonと同じでkey, valueみたいな感じ
    * 文字列はインデックスと<code>rune</code>型になる
    * Unicodeのコードポイントごとにインデックスが振られるので注意（よくわからん）
#### switchのとこで気になったやつ
* 式によるswitch
    * if同様簡易文を使える
    * 条件も使える。<code>case n>0 && n%2==0</code>みたいな
        * <b>この場合はswtichの条件は無しにするのが当然</b>。各caseでboolを返すのでswtich（のあとに続く条件節）で管理しなくてもいい。無しだと自動的にtrueと見なされる    * caseで与える条件はコンマ区切りで複数与えることができる
    * フォールスルーしない。ひとつでもcase節が実行されると終了する。フォールスルーさせる場合は明示的に<code>fallthrough</code>キーワードを使う
    * 条件が式と定数の混在だとエラーになる
        ```
        switch x:=1; x{
            case 1, 2, 3:
                fmt.Println("xは1,2,3のどれか")
            case x%2==0:
                //そもそもフォールスルーが働かないのでスルーされる
                fmt.Println("xは偶数")
            default:
                fmt.Println("あばばばばばばばばば")
        }
        ```
        このコードは<code>invalid case x % 2 == 0 in switch on x (mismatched types bool and int)</code>ということでエラーになる
#### 型アサーション
* 型によるswitch（後述）を実現するための機能
* 動的に変数の型をチェックする
* <code>interface{}</code>はすべての型をとることができるが、型をとったときに自分自身の型がなんなのかを知ることができる
* <code>interfaceの変数名.(型名)</code>という形でチェック
```
	// 型アサーション
	var x interface{} = 10
	i:=x
	fmt.Println(i.(int))	// > 10
	// ２つの変数に入れると二つ目の戻り値でエラーを吐かずにboolで返る
	j, isString := x.(string)
	fmt.Println(j, isString)//> (空文字) false
```
#### 型によるswitch
* 型アサーションと分岐を組み合わせたお手軽なswtich記述法。組み合わせたといいつつ<code>.(type)</code>は<strong>switch文でしか使えないっぽい。</strong>
    * <code>use of .(type) outside type switch</code>なるエラーなんて珍しいな
```
switch interface型の変数.(type){
    case bool:
        fmt.Println("bool型")
    case int, uint:
        fmt.Println("int型")
    case string:
        fmt.Println("文字列型")
    default:
        fmt.Println("なんだお前")
}
```
また、値をとりたいときは<code>v:=interface型の変数.(type)</code>とすればよい
* ただし、caseのあとの条件列挙で複数の型を指定するとそのうち１つでもあっていればcase節が実行されるので、interface型として認識される（単一の型であれば自動的にその型が割り振られる）<br>
```
var z interface{} = "おっぱい"
switch z.(type){
    case int, uint, string:
        fmt.Println(z+z)
}
```
これは<code>invalid operation: z + z (operator + not defined on interface)</code>というエラーになる

#### ラベル付き文のとこで気になったやつ
* gotoはクソ
* goto代わりに使える
* <code>break ラベル名</code>あるいは<code>continue ラベル名</code>みたいな感じでラベルの貼られたところまで抜ける
* <code>break</code>は一階層だけジャンプするがラベル付きbreak文はラベルまで一気に抜けられるのでネストの深いところで条件に一致したとき処理を終了させてループを抜ける、みたいな感じで使える
```
// 深いネストから一気にぬけられる
A:=[5]int{2, 5, 8, 11, 13}
B:=[8]int{1, 3, 5, 10, 14, 15, 16, 17}
C:=[4]int{5, 6, 8, 21}
var ans int
MYLABEL:
    for _, a:=range A{
        for _, b:=range B{
            for _, c:=range C{
                if (a+b+c)%7==0{
                fmt.Printf("最初に7で割り切れる組み合わせは%d+%d+%d\n", a, b, c)
                ans = a+b+c
                break MYLABEL
                }
            }
        }
    }
fmt.Println(ans)
```
という感じ
* <code>continue ラベル名</code>はそこまでで処理を中断し、ラベルで示されているループの次の繰り返し処理の先頭へジャンプする
    * うまいサンプルがわからんのでサンプルなし・・・


#### deferのとこで気になったやつ
* 関数の最後に実行される<strong>関数</strong>を登録
    * 関数というか関数呼び出しの形態のやつに限る。<code>fmt.Println()</code>とか
* リソースの開放処理なんかで力を発揮するらしい
* deferにはいくつでも登録できるが最終的に呼び出されるときはスタック形式で最後に登録されたものから呼び出される

#### panicとrecoverのとこで気になったやつ
* 多用しちゃいけないタイプの例外処理
* panic
    * <code>func panic(v interface{})</code>と定義されているのでなにがしかのインターフェースを引数にとってなにも返さない関数？
    * panicが実行されるとその場でランタイムエラーになる
    * 回復不可能な事態になったときにセーフティネットで自死する感じ？
    * ちなみにpanic時でもdeferはちゃんと呼び出されるらしい
* recover
    * panicからの回復
    * <b>実質的にdeferの中でしか動作しない</b>（できないという意味で）
        * panic起こる → そこでプログラムが中断するがdeferは実行される → deferの中でrecoverしとけばpanicから復帰できる
    * > recoverはinterface{}型の値を戻し、その値がnilでなければpanicが実行されたと判断することができます。  
        * ?????????????????????????????????なにいってんのか説明不足というかわからん
        * そもそもrecoverはほとんど使われないらしいしわからんでいいかな・・標準ライブラリでも数カ所しか使われてないらしい
    
#### goのとこできになったやつ
* 並行処理をするやつ。goではコルーチンではなくゴルーチンと呼ぶ
* deferと同じく関数呼び出しの形を受取る
    * 無名関数でもいい
````
//メインのforがおわった時点で終わる？っぽい？？？？
//なのでsubと無名関数が10回出力されてなくても終わる？

func sub1(){
	for i:=0; i<10; i++{
		fmt.Println("I am sub")
	}
}

func main(){
	//関数呼び出しのゴルーチン
	go sub1()
	// 無名関数のゴルーチン
	go func(){
		for i:=0; i<10; i++{
			fmt.Println("I am goroutin")
		}
	}()
	for i:=0; i<10; i++{
		fmt.Println("MAIN")
	}
}
````
* runtimeパッケージによる計測
    * PCの環境とかGoランタイムが動作する環境がわかるライブラリ
    * <code>runtime.NumGoroutine()</code>でいま走っているゴルーチンの数がわかる

#### initのとこで気になったやつ
* クラスの初期化とかじゃなくて（そもそもGoにクラスは無い）パッケージの初期化を目的にした関数
* 開発者自身が定義できる


### まとめ
* ここでやっと書籍内の書式について出て来るの新しい。こっからが本番だという気持ち
* <code>Println</code>のほかにデバッグ用に<code>println</code>があるだなんて
* python的に右辺の配列を左辺の複数の変数に暗黙的にアンジップして代入できないかとかやったけどダメみたいですね( startinggo/chap3/variable_sample1.go )
* パッケージ変数とかいう新概念（ただの名前空間）
* rune型はUnicodeを単一の型でがんばって表そうとしている（?
* 要素数ゼロの配列とか作れる
* 相変わらずクロージャとかよくわからん
* iota、定数との絡みでしか言及されず、ろくな説明もなかったのだが読み方すらわからんのだが一体なんなの
* スコープ、識別子の名前の1文字目で判断できるのヤバイ
* ifやswitchでの簡易文は積極的に使うことが望まれるらしい。変数の局所製を高めるというらしいがよくわからん
* 型アサーションは重要そうな概念。型がなにかを知りたいときにforでいちいち回したりするのではなくswith文と組み合わせた型アサーションで書くとシンプルに書ける、以外のメリットはなんだろうか